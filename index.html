<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USDT Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: white;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
        }
        h1, label, select {
            margin: 10px 0;
        }
        canvas {
            max-width: 95%;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>BTC/USDT Dashboard</h1>

    <!-- Timeframe Selector -->
    <label for="timeframe">Select Timeframe:</label>
    <select id="timeframe">
        <option value="1m">1 Minute</option>
        <option value="5m">5 Minutes</option>
        <option value="15m">15 Minutes</option>
        <option value="1h">1 Hour</option>
        <option value="4h">4 Hours</option>
        <option value="1d">1 Day</option>
    </select>

    <!-- Combined BTC/USDT and Open Interest Chart -->
    <h2>BTC/USDT and Open Interest</h2>
    <canvas id="combinedChart"></canvas>

    <!-- Order Book Filter -->
    <h2>Filtered Order Book</h2>
    <label for="minQty">Minimum Quantity (BTC):</label>
    <input type="number" id="minQty" value="50" step="1" min="1">

    <canvas id="orderBookChart"></canvas>

    <script>
        const symbol = "BTCUSDT";
        let minQty = 50; // Default minimum quantity filter set to 50
        let orderBook = { bids: [], asks: [] }; // Order book data
        let combinedChart, orderBookChart;

        // WebSocket for Order Book
        const wsOrderBook = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@depth`);

        wsOrderBook.onmessage = (event) => {
            const data = JSON.parse(event.data);
            updateOrderBook(data.b, data.a);
            updateOrderBookChart();
        };

        // Function to update the Order Book data
        function updateOrderBook(bids, asks) {
            // Process Bids
            bids.forEach(([price, quantity]) => {
                const priceNum = parseFloat(price);
                const quantityNum = parseFloat(quantity);
                if (quantityNum >= minQty) { // Only include bids that meet the minQty
                    const existing = orderBook.bids.find(order => order.price === priceNum);
                    if (existing) {
                        existing.quantity = quantityNum;
                    } else {
                        orderBook.bids.push({ price: priceNum, quantity: quantityNum });
                    }
                }
            });

            // Process Asks
            asks.forEach(([price, quantity]) => {
                const priceNum = parseFloat(price);
                const quantityNum = parseFloat(quantity);
                if (quantityNum >= minQty) { // Only include asks that meet the minQty
                    const existing = orderBook.asks.find(order => order.price === priceNum);
                    if (existing) {
                        existing.quantity = quantityNum;
                    } else {
                        orderBook.asks.push({ price: priceNum, quantity: quantityNum });
                    }
                }
            });

            // Sort bids (descending) and asks (ascending)
            orderBook.bids.sort((a, b) => b.price - a.price);
            orderBook.asks.sort((a, b) => a.price - b.price);
        }

        // Initialize the Order Book Chart
        function initializeOrderBookChart() {
            const ctx = document.getElementById("orderBookChart").getContext("2d");
            orderBookChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: [], // Will be populated dynamically with actual price levels
                    datasets: [
                        {
                            label: "Bids",
                            data: [],
                            backgroundColor: "rgba(76, 175, 80, 0.7)", // Green
                        },
                        {
                            label: "Asks",
                            data: [],
                            backgroundColor: "rgba(244, 67, 54, 0.7)", // Red
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            title: { display: true, text: "Price Levels (USDT)" },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(2); // Format price to 2 decimal places
                                }
                            }
                        },
                        y: {
                            title: { display: true, text: "Quantity (BTC)" }
                        }
                    }
                }
            });
        }

        // Update the Order Book Chart
        function updateOrderBookChart() {
            // Combine bids and asks, and sort them from lower to higher price
            const allOrders = [...orderBook.bids, ...orderBook.asks];
            allOrders.sort((a, b) => a.price - b.price); // Sort by price from low to high

            // Labels: actual price levels from low to high
            const labels = allOrders.map(order => order.price.toFixed(2)); 

            // Quantities for Bids and Asks
            const bidQuantities = [];
            const askQuantities = [];
            allOrders.forEach(order => {
                if (orderBook.bids.includes(order)) {
                    bidQuantities.push(order.quantity);
                    askQuantities.push(0); // No ask at this price level
                } else {
                    askQuantities.push(order.quantity);
                    bidQuantities.push(0); // No bid at this price level
                }
            });

            // Set the X-axis labels to actual price levels
            orderBookChart.data.labels = labels;
            orderBookChart.data.datasets[0].data = bidQuantities; // Bids
            orderBookChart.data.datasets[1].data = askQuantities; // Asks

            orderBookChart.update();
        }

        // --- Combined BTC/USDT and Open Interest Chart ---
        async function fetchCombinedChartData(timeframe) {
            try {
                const priceDataResponse = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${timeframe}&limit=50`);
                const priceData = await priceDataResponse.json();

                const openInterestDataResponse = await fetch(`https://fapi.binance.com/futures/data/openInterestHist?symbol=${symbol}&period=${timeframe}&limit=50`);
                const openInterestData = await openInterestDataResponse.json();

                return priceData.map((entry, index) => ({
                    time: new Date(entry[0]).toLocaleTimeString(),
                    price: parseFloat(entry[4]),
                    openInterest: openInterestData[index] ? parseFloat(openInterestData[index].sumOpenInterest) : 0
                }));
            } catch (error) {
                console.error("Error fetching combined chart data:", error);
                return [];
            }
        }

        async function renderCombinedChart(timeframe) {
            const data = await fetchCombinedChartData(timeframe);

            if (!data.length) {
                alert("No data available!");
                return;
            }

            const labels = data.map(entry => entry.time);
            const prices = data.map(entry => entry.price);
            const openInterest = data.map(entry => entry.openInterest);

            const ctx = document.getElementById("combinedChart").getContext("2d");
            if (combinedChart) combinedChart.destroy();

            combinedChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels,
                    datasets: [
                        {
                            label: "BTC/USDT Price",
                            data: prices,
                            borderColor: "rgba(255, 206, 86, 1)",
                            backgroundColor: "rgba(255, 206, 86, 0.2)",
                            borderWidth: 2,
                            yAxisID: 'y'
                        },
                        {
                            label: "Open Interest",
                            data: openInterest,
                            borderColor: "rgba(75, 192, 192, 1)",
                            backgroundColor: "rgba(75, 192, 192, 0.2)",
                            borderWidth: 2,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { title: { display: true, text: "Time" } },
                        y: {
                            title: { display: true, text: "Price (USDT)" },
                            position: 'left',
                            grid: { color: 'rgba(255, 206, 86, 0.2)' }
                        },
                        y1: {
                            title: { display: true, text: "Open Interest" },
                            position: 'right',
                            grid: { drawOnChartArea: false }
                        }
                    }
                }
            });
        }

        // --- Event Listeners ---
        document.getElementById("timeframe").addEventListener("change", (event) => {
            const timeframe = event.target.value;
            renderCombinedChart(timeframe);
        });

        document.getElementById("minQty").addEventListener("input", (event) => {
            minQty = parseFloat(event.target.value);
            orderBook.bids = orderBook.bids.filter(order => order.quantity >= minQty);
            orderBook.asks = orderBook.asks.filter(order => order.quantity >= minQty);
            updateOrderBookChart(); // Refresh the order book chart with the new filter
        });

        // Initialize charts
        initializeOrderBookChart();
        renderCombinedChart("1m");
    </script>
</body>
</html>